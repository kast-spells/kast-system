{{/*kast - Kubernetes arcane spelling technology
Copyright (C) 2023 namenmalkv@gmail.com
Licensed under the GNU GPL v3. See LICENSE file for details.

s3.seaweed - SeaweedFS S3 infrastructure setup

Creates:
1. EventSource (resource type, watching secrets in seaweedfs namespace)
2. Sensor (triggers aggregator pod on secret changes)
3. ConfigMap (aggregator script)
4. ServiceAccount + RBAC (for aggregator pod)
5. Prolicy (vault access for /s3-identities/*)

The aggregator script:
- Lists all secrets with label kast.ing/s3-identity=true
- Reads credentials and metadata
- Builds S3 config JSON (SeaweedFS format with actions: ["Action:Bucket"])
- Creates/updates Secret with s3.json
- Restarts seaweedfs-s3 deployment
- Waits for deployment to be ready
- Creates buckets using aws-cli with admin credentials

Identity permissions logic:
- Admin users: actions: ["Admin"] (full access)
- Users with buckets: actions: ["Read:bucket", "Write:bucket", "List:bucket"]
- Users without buckets or with "*": actions: ["Read", "Write", "List"] (global)
- Default permissions: Read, Write, List

Bucket creation:
- Waits for SeaweedFS to reload config after restart
- Uses seaweedfs-s3-admin credentials (must have ADMIN: true label)
- Creates all buckets found in identity actions (ignores wildcards)
- Idempotent: fails gracefully if bucket exists
*/}}

{{- define "s3.seaweed.impl" -}}
{{- $root := index . 0 -}}
{{- $glyphDefinition := index . 1 -}}
{{- $name := $glyphDefinition.name -}}

{{- /* Find EventBus via runicIndexer (default: book fallback) */}}
{{- $eventBusSelector := default (dict "default" "book") $glyphDefinition.eventBusSelector }}
{{- $eventBuses := get (include "runicIndexer.runicIndexer" (list $root.Values.lexicon $eventBusSelector "eventbus" $root.Values.chapter.name) | fromJson) "results" }}

{{- if not $eventBuses }}
  {{- fail "s3.seaweed: No EventBus found. Ensure argo-events is deployed with eventbus lexicon entry." }}
{{- end }}

{{- $eventBus := index $eventBuses 0 }}

{{- /* 1. EventSource - Watching secrets in provider namespace */}}
{{- /* EventSource lives in EventBus namespace but watches secrets in provider namespace */}}
{{ include "argo-events.eventSource" (list $root (dict
  "name" (printf "%s-s3-secrets" $name)
  "eventBusName" $eventBus.name
  "template" (dict
    "serviceAccountName" (printf "%s-s3-aggregator" $name)
  )
  "resource" (dict
    "s3-identity-changes" (dict
      "namespace" $root.Release.Namespace
      "group" ""
      "version" "v1"
      "resource" "secrets"
      "eventTypes" (list "ADD" "UPDATE" "DELETE")
      "filter" (dict
        "afterStart" true
        "labels" (list
          (dict "key" "kast.ing/s3-identity" "operation" "=" "value" "true")
        )
      )
    )
  )
)) }}

{{- /* 2. Aggregator Script ConfigMap */}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ $name }}-s3-aggregator-script
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
data:
  aggregator.sh: |
    #!/bin/sh
    set -euo pipefail
    apk add --no-cache jq aws-cli
    echo "ðŸ” Starting S3 identity aggregation..."

    # Find all S3 identity secrets in current namespace
    SECRETS_JSON=$(kubectl get secrets -n ${NAMESPACE} \
      -l kast.ing/s3-identity=true \
      -o json)

    # Count secrets
    SECRET_COUNT=$(echo "$SECRETS_JSON" | jq '.items | length')
    echo "INFO: Found $SECRET_COUNT S3 identity secret(s)"

    if [ "$SECRET_COUNT" -eq 0 ]; then
      echo "WARNING: No S3 identities found, creating empty config"
      IDENTITIES="[]"
    else
      # Build identities array from secrets
      # CRITICAL: Secrets must have all required keys (no defaults)
      # - Admin secrets: ADMIN="true" (PERMISSIONS and BUCKETS optional)
      # - Normal secrets: PERMISSIONS and BUCKETS required (generated by s3.bucket glyph)
      IDENTITIES=$(echo "$SECRETS_JSON" | jq -r '
        .items | map(
          # Check if admin (optional, defaults to false)
          ((.data.ADMIN // "ZmFsc2U=") | @base64d) as $isAdmin |

          # For non-admin secrets, PERMISSIONS and BUCKETS are REQUIRED
          if ($isAdmin != "true") then
            if (.data.PERMISSIONS | not) then
              error("Secret \(.metadata.name) is missing required key PERMISSIONS (must be generated via s3.bucket glyph)")
            elif (.data.BUCKETS | not) then
              error("Secret \(.metadata.name) is missing required key BUCKETS (must be generated via s3.bucket glyph)")
            else . end
          else . end |

          # Extract permissions and buckets (only after validation)
          (if (.data.PERMISSIONS) then ((.data.PERMISSIONS | @base64d | split(",")) | map(select(length > 0))) else [] end) as $permissions |
          (if (.data.BUCKETS) then ((.data.BUCKETS | @base64d | split(",")) | map(select(length > 0))) else [] end) as $buckets |

          {
            name: (.metadata.labels."kast.ing/identity-name" // .metadata.name),
            credentials: [{
              accessKey: (.data.AWS_ACCESS_KEY_ID | @base64d),
              secretKey: (.data.AWS_SECRET_ACCESS_KEY | @base64d)
            }],
            actions: (
              # Admin users: actions: ["Admin"] (full access)
              if ($isAdmin == "true") then
                ["Admin"]
              # No buckets or wildcard "*": use permissions without scope
              elif ($buckets | length == 0) or ($buckets | contains(["*"])) then
                $permissions
              # Combine each permission with each bucket: "Action:Bucket"
              else
                [$buckets[] as $bucket | $permissions[] | . + ":" + $bucket]
              end
            )
          }
        )
      ')
    fi

    # Build final S3 config
    S3_CONFIG=$(jq -n --argjson identities "$IDENTITIES" '{identities: $identities}')

    echo "INFO: Generated S3 config with ${SECRET_COUNT} identities"

    # Create/update Secret (NOT ConfigMap for security)
    # Key name is s3.json to match the file path expected by SeaweedFS
    kubectl create secret generic seaweedfs-s3-config \
      -n ${NAMESPACE} \
      --from-literal=s3.json="$S3_CONFIG" \
      --dry-run=client -o yaml | \
      kubectl apply -f -

    echo "SUCCESS: Secret updated successfully"

    # Restart seaweedfs-s3 deployment to reload config
    echo "Restarting seaweedfs-s3 deployment..."
    kubectl rollout restart deployment/seaweedfs-s3 -n ${NAMESPACE} || true

    # Wait for deployment to be ready (max 60s)
    # Pod will automatically send SIGHUP to itself via lifecycle.postStart hook
    echo "Waiting for seaweedfs-s3 to be ready..."
    kubectl wait --for=condition=available --timeout=60s deployment/seaweedfs-s3 -n ${NAMESPACE} || {
      echo "WARNING: Deployment did not become ready in time, skipping bucket creation"
      echo "SUCCESS: S3 aggregation complete (buckets creation skipped)"
      exit 0
    }

    # Give SeaweedFS extra time for lifecycle hook (postStart: sleep 3 + SIGHUP + config load)
    echo "Waiting 10s for lifecycle hook to complete and config to load..."
    sleep 10

    # Create buckets for each identity
    echo "Creating buckets..."

    # Get admin credentials for bucket creation
    ADMIN_ACCESS_KEY=$(kubectl get secret seaweedfs-s3-admin -n ${NAMESPACE} -o jsonpath='{.data.AWS_ACCESS_KEY_ID}' | base64 -d)
    ADMIN_SECRET_KEY=$(kubectl get secret seaweedfs-s3-admin -n ${NAMESPACE} -o jsonpath='{.data.AWS_SECRET_ACCESS_KEY}' | base64 -d)

    if [ -z "$ADMIN_ACCESS_KEY" ] || [ -z "$ADMIN_SECRET_KEY" ]; then
      echo "WARNING: Admin credentials not found, skipping bucket creation"
    else
      # S3 endpoint (internal service)
      S3_ENDPOINT="http://seaweedfs-s3.${NAMESPACE}.svc:8333"

      # Configure aws-cli credentials (signature v2 compatible with SeaweedFS)
      export AWS_ACCESS_KEY_ID="${ADMIN_ACCESS_KEY}"
      export AWS_SECRET_ACCESS_KEY="${ADMIN_SECRET_KEY}"
      export AWS_DEFAULT_REGION="us-east-1"

      # Extraer nombres Ãºnicos de buckets desde actions (formato "Action:Bucket"), ignorando wildcards
      BUCKET_LIST=$(echo "$IDENTITIES" | jq -r '.[].actions[]' | grep ':' | sed 's/.*://' | grep -v '\*' | sort -u)

      if [ -z "$BUCKET_LIST" ]; then
          echo "INFO: No buckets to create (empty or wildcard only)"
      else
          BUCKET_COUNT=$(echo "$BUCKET_LIST" | wc -l)
          echo "INFO: Found $BUCKET_COUNT unique bucket(s) to create"

          for bucket in $BUCKET_LIST; do
              echo "  Creating bucket: $bucket"
              if aws s3 mb "s3://${bucket}" \
                      --endpoint-url="${S3_ENDPOINT}" 2>&1; then
                  echo "SUCCESS: Bucket ${bucket} created successfully"
              else
                  echo "WARNING: Bucket ${bucket} creation failed (may already exist)"
              fi
          done
      fi
    fi

    echo "ðŸŽ‰ S3 aggregation complete!"

{{- /* 3. Sensor - Triggers aggregator pod on secret changes */}}
{{ include "argo-events.sensor" (list $root (dict
  "name" (printf "%s-s3-aggregator" $name)
  "eventBusName" $eventBus.name
  "template" (dict
    "serviceAccountName" (printf "%s-s3-aggregator" $name)
  )
  "dependencies" (list
    (dict
      "name" "s3-secret-event"
      "eventSourceName" (printf "%s-s3-secrets" $name)
      "eventName" "s3-identity-changes"
    )
  )
  "triggers" (list
    (dict
      "name" "run-aggregator"
      "type" "k8s"
      "rateLimit" (dict
        "unit" "Minute"
        "requestsPerUnit" 1
      )
      "k8s" (dict
        "group" ""
        "version" "v1"
        "resource" "pods"
        "operation" "create"
        "source" (dict
          "resource" (dict
            "apiVersion" "v1"
            "kind" "Pod"
            "metadata" (dict
              "generateName" (printf "%s-s3-aggregator-" $name)
              "namespace" $root.Release.Namespace
            )
            "spec" (dict
              "serviceAccountName" (printf "%s-s3-aggregator-pod" $name)
              "restartPolicy" "Never"
              "containers" (list
                (dict
                  "name" "aggregator"
                  "image" "alpine/kubectl:latest"
                  "command" (list "/bin/sh" "-c" "source /scripts/aggregator.sh")
                  "env" (list
                    (dict "name" "NAMESPACE" "value" $root.Release.Namespace)
                  )
                  "volumeMounts" (list
                    (dict "name" "script" "mountPath" "/scripts")
                  )
                  "resources" (dict
                    "requests" (dict "cpu" "50m" "memory" "64Mi")
                    "limits" (dict "cpu" "200m" "memory" "128Mi")
                  )
                )
              )
              "volumes" (list
                (dict
                  "name" "script"
                  "configMap" (dict "name" (printf "%s-s3-aggregator-script" $name))
                )
              )
            )
          )
        )
      )
    )
  )
)) }}

{{- /* 4. ServiceAccount + RBAC for EventSource and Sensor (in EventBus namespace) */}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ $name }}-s3-aggregator
  namespace: {{ $eventBus.namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
---
{{- /* Role for EventSource to watch secrets in seaweedfs namespace */}}
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ $name }}-s3-eventsource
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ $name }}-s3-eventsource
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $name }}-s3-eventsource
subjects:
  - kind: ServiceAccount
    name: {{ $name }}-s3-aggregator
    namespace: {{ $eventBus.namespace }}
---
{{- /* Role for Sensor to create pods in seaweedfs namespace */}}
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ $name }}-s3-sensor
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["create", "get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ $name }}-s3-sensor
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $name }}-s3-sensor
subjects:
  - kind: ServiceAccount
    name: {{ $name }}-s3-aggregator
    namespace: {{ $eventBus.namespace }}

{{- /* 5. ServiceAccount + RBAC for aggregator pod (in app namespace) */}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ $name }}-s3-aggregator-pod
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ $name }}-s3-aggregator-pod
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "create", "update", "patch"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ $name }}-s3-aggregator-pod
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $name }}-s3-aggregator-pod
subjects:
  - kind: ServiceAccount
    name: {{ $name }}-s3-aggregator-pod
    namespace: {{ $root.Release.Namespace }}

{{- /* 6. Vault Prolicy for s3-identities access - uses naming convention in /publics/ */}}
{{- /* Vault + wildcard matches single directory between slashes, can chain for multiple levels */}}
{{- /* See: https://developer.hashicorp.com/vault/docs/concepts/policies#policy-syntax */}}
{{- $vaultServers := get (include "runicIndexer.runicIndexer" (list $root.Values.lexicon (default dict (dict)) "vault" $root.Values.chapter.name) | fromJson) "results" }}
{{- $vault := index $vaultServers 0 }}
{{ include "vault.prolicy" (list $root (dict
  "nameOverride" (printf "%s-s3-identities" $name)
  "serviceAccount" (printf "%s-s3-aggregator-pod" $name)
  "extraPolicy" (list
    (dict
      "path" (printf "%s/data/%s/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
    (dict
      "path" (printf "%s/metadata/%s/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
    (dict
      "path" (printf "%s/data/%s/+/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
    (dict
      "path" (printf "%s/metadata/%s/+/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
    (dict
      "path" (printf "%s/data/%s/+/+/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
    (dict
      "path" (printf "%s/metadata/%s/+/+/+/publics/s3-identities-%s-*" $vault.secretPath $root.Values.spellbook.name $name)
      "capabilities" (list "read" "list")
    )
  )
)) }}

{{- /* 7. Additional KubernetesAuthEngineRole using serviceAccount name for transparent auth */}}
{{- /* This allows VaultSecrets to use role: {name}-s3-aggregator-pod (same as serviceAccount) */}}
{{- /* The vault.connect logic defaults role=serviceAccount when no customRole is provided */}}
{{- /* So this makes the auth "just work" without explicit role configuration */}}
---
apiVersion: redhatcop.redhat.io/v1alpha1
kind: KubernetesAuthEngineRole
metadata:
  name: {{ $name }}-s3-aggregator-pod
  namespace: {{ $vault.namespace }}
  labels:
    {{- include "common.all.labels" $root | nindent 4 }}
    {{- with $glyphDefinition.labels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  {{- with $glyphDefinition.annotations }}
  annotations:
    {{- include "common.annotations" $root | nindent 4 }}
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- include "vault.connect" (list $root $vault "True") | nindent 2 }}
  path: {{ default $root.Values.spellbook.name $vault.path }}
  policies:
    - {{ $name }}-s3-identities
  targetServiceAccounts:
    - {{ $name }}-s3-aggregator-pod
  targetNamespaces:
    targetNamespaces:
      - {{ $root.Release.Namespace }}

{{- end }}
