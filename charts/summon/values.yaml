# Summon - Kubernetes Workload Deployment Chart
# This chart can deploy Deployments, StatefulSets, Jobs, CronJobs, and DaemonSets

# Workload configuration
workload:
  enabled: true
  type: deployment  # Options: deployment, statefulset, job, cronjob, daemonset
  replicas: 1       # Number of replicas (ignored for daemonset and jobs)

  # For StatefulSet workloads - volumeClaimTemplates
  # volumeClaimTemplates:
  #   data-volume:
  #     destinationPath: /data
  #     size: 10Gi
  #     storageClass: fast-ssd  # Optional, uses default if not specified
  #     accessModes: ReadWriteOnce  # Optional, default: ReadWriteOnce
  #   cache-volume:
  #     destinationPath: /cache
  #     size: 5Gi

  # For CronJob workloads - schedule is mandatory
  # schedule: "0 3 * * *"  # Run daily at 3 AM
  # schedule: "*/5 * * * *"  # Run every 5 minutes

  # For Job/CronJob workloads
  # backoffLimit: 3  # Number of retries before marking job as failed
  # activeDeadlineSeconds: 600  # Maximum time in seconds for job to complete

# Container image configuration
image:
  repository: ""  # e.g., nginx, myapp, ghcr.io/org/app
  pullPolicy: IfNotPresent  # Options: Always, IfNotPresent, Never
  name: ""  # Optional, container name override
  tag: ""   # Overrides chart appVersion if specified

imagePullSecrets: []
# - name: regcred
# - name: dockerhub-secret

nameOverride: ""     # Override the chart name
fullnameOverride: "" # Override the full generated name

# ServiceAccount configuration
serviceAccount:
  enabled: true      # Create a ServiceAccount for the workload
  automount: true    # Automatically mount ServiceAccount token
  annotations: {}    # Annotations for the ServiceAccount
  # vault.hashicorp.com/role: my-app
  # eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/my-role
  labels: {}
  name: ""  # Custom name, auto-generated if empty

# Pod configuration
podAnnotations: {}
# prometheus.io/scrape: "true"
# prometheus.io/port: "8080"
# prometheus.io/path: "/metrics"

podLabels: {}
# version: "1.0.0"
# environment: "production"

podSecurityContext: {}
# fsGroup: 2000
# runAsNonRoot: true
# runAsUser: 1000
# runAsGroup: 3000
# fsGroupChangePolicy: "OnRootMismatch"

securityContext: {}
# capabilities:
#   drop:
#   - ALL
#   add:
#   - NET_BIND_SERVICE
# readOnlyRootFilesystem: true
# runAsNonRoot: true
# runAsUser: 1000
# allowPrivilegeEscalation: false

# Service configuration
service:
  enabled: true
  type: ClusterIP  # Options: ClusterIP, NodePort, LoadBalancer
  annotations: {}
  # service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
  # cloud.google.com/neg: '{"ingress": true}'
  labels: {}
  ports: []
  # - port: 80         # Service port
  #   targetPort: 8080 # Container port (optional, defaults to port)
  #   protocol: TCP    # TCP or UDP
  #   name: http       # Port name
  # - port: 443
  #   targetPort: 8443
  #   protocol: TCP
  #   name: https
  #   nodePort: 30443  # Required for NodePort service type

# Resource limits and requests
resources: {}
# limits:
#   cpu: 500m
#   memory: 512Mi
# requests:
#   cpu: 250m
#   memory: 256Mi

# Health checks - liveness, readiness, and startup probes
# probes:
#   liveness:
#     type: httpGet
#     path: /healthz
#     port: 8080
#     initialDelaySeconds: 30
#     periodSeconds: 10
#     timeoutSeconds: 5
#     successThreshold: 1
#     failureThreshold: 3
#     httpHeaders:
#     - name: X-Custom-Header
#       value: "HealthCheck"
#   readiness:
#     type: tcpSocket
#     port: 8080
#     initialDelaySeconds: 5
#     periodSeconds: 5
#     timeoutSeconds: 1
#     successThreshold: 1
#     failureThreshold: 3
#   startup:
#     type: exec
#     command:
#     - /bin/sh
#     - -c
#     - "test -f /app/ready"
#     initialDelaySeconds: 0
#     periodSeconds: 10
#     timeoutSeconds: 1
#     successThreshold: 1
#     failureThreshold: 30

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80
  # behavior:  # Advanced HPA behavior
  #   scaleDown:
  #     stabilizationWindowSeconds: 300
  #   scaleUp:
  #     stabilizationWindowSeconds: 60

# Node selection
nodeSelector: {}
# disktype: ssd
# node.kubernetes.io/instance-type: t3.large

# Tolerations for pod scheduling
tolerations: []
# - key: "key1"
#   operator: "Equal"
#   value: "value1"
#   effect: "NoSchedule"
# - key: "node.kubernetes.io/unreachable"
#   operator: "Exists"
#   effect: "NoExecute"
#   tolerationSeconds: 300

# Affinity rules
affinity: {}
# podAntiAffinity:
#   preferredDuringSchedulingIgnoredDuringExecution:
#   - weight: 100
#     podAffinityTerm:
#       topologyKey: kubernetes.io/hostname
#       labelSelector:
#         matchLabels:
#           app: myapp
# nodeAffinity:
#   requiredDuringSchedulingIgnoredDuringExecution:
#     nodeSelectorTerms:
#     - matchExpressions:
#       - key: node-role.kubernetes.io/worker
#         operator: In
#         values:
#         - "true"

# Init containers - run before main container
initContainers: {}
# db-migration:
#   image:
#     repository: migrate/migrate
#     tag: latest
#   command:
#   - migrate
#   args:
#   - -path=/migrations
#   - -database=postgres://user:pass@db/mydb
#   - up
#   resources:
#     limits:
#       cpu: 200m
#       memory: 256Mi
# wait-for-db:
#   image:
#     repository: busybox
#     tag: latest
#   command: ['sh', '-c', 'until nc -z db 5432; do sleep 1; done']

# Sidecar containers - run alongside main container
sideCars: {}
# prometheus-exporter:
#   image:
#     repository: prom/node-exporter
#     tag: latest
#   resources:
#     limits:
#       cpu: 100m
#       memory: 128Mi
# cloud-sql-proxy:
#   image:
#     repository: gcr.io/cloudsql-docker/gce-proxy
#     tag: latest
#   command:
#   - /cloud_sql_proxy
#   - -instances=project:region:instance=tcp:5432

# Secrets configuration - unified contentType approach
secrets: {}
# db-credentials:
#   contentType: env  # All keys will be added to envFrom
#   location: local   # Reference existing secret
# tls-cert:
#   contentType: file  # Mount as file
#   location: local
#   mountPath: /etc/tls
#   name: tls.crt
# api-key:
#   contentType: file
#   location: create  # Create the secret
#   mountPath: /etc/api
#   content: "sk_live_abcdef123456"
# app-secrets:
#   contentType: yaml  # YAML formatted file
#   location: create
#   mountPath: /config
#   name: secrets.yaml
#   content:
#     database:
#       host: postgres.local
#       password: secretpass

# ConfigMaps configuration - unified contentType approach
configMaps: {}
# app-env-vars:
#   contentType: env  # All keys as environment variables
#   location: local   # Reference existing ConfigMap
# app-config:
#   contentType: yaml  # YAML formatted config file
#   location: create
#   name: config.yaml
#   mountPath: /app/config
#   content:
#     server:
#       port: 8080
#       host: 0.0.0.0
#     features:
#       cache: true
#       metrics: true
# nginx-conf:
#   contentType: file  # Plain text file
#   location: create
#   name: nginx.conf
#   mountPath: /etc/nginx
#   content: |
#     server {
#       listen 80;
#       location / {
#         proxy_pass http://backend;
#       }
#     }
# app-settings:
#   contentType: json  # JSON formatted file
#   location: create
#   name: settings.json
#   mountPath: /app/settings
#   content:
#     debug: false
#     timeout: 30
#     retries: 3

# Volumes configuration
volumes: {}
# # PersistentVolumeClaim - existing
# data-existing:
#   type: pvc
#   destinationPath: /data
#   pvcName: existing-pvc-name
#   readOnly: false
#
# # PersistentVolumeClaim - create new
# data-new:
#   type: pvc
#   destinationPath: /var/data
#   create: true
#   size: 10Gi
#   storageClass: fast-ssd
#   accessMode: ReadWriteOnce
#
# # HostPath volume
# host-data:
#   type: hostPath
#   destinationPath: /host/data
#   path: /var/lib/data
#
# # NFS volume
# shared-data:
#   type: nfs
#   destinationPath: /mnt/nfs
#   server: nfs.example.com
#   path: /exports/data
#   readOnly: false
#
# # EmptyDir volume
# temp-data:
#   type: emptyDir
#   destinationPath: /tmp/data
#   sizeLimit: 1Gi
#   medium: Memory  # Optional: Memory for tmpfs

# Environment variables
envs: {}
# # Simple key-value
# LOG_LEVEL: debug
# APP_ENV: production
#
# # From secret
# DB_PASSWORD:
#   type: secret
#   name: db-secret
#   key: password
#
# # From ConfigMap
# API_ENDPOINT:
#   type: configmap
#   name: app-config
#   key: api.endpoint

# Command and arguments override
# command: ["nginx"]
# args: ["-g", "daemon off;"]

# Lifecycle hooks
# lifecycle:
#   preStop:
#     exec:
#       command: ["/bin/sh", "-c", "nginx -s quit; while killall -0 nginx; do sleep 1; done"]
#   postStart:
#     httpGet:
#       path: /healthz
#       port: 8080

# DNS configuration
# dnsPolicy: ClusterFirst
# dnsConfig:
#   nameservers:
#   - 8.8.8.8
#   searches:
#   - example.com
#   options:
#   - name: ndots
#     value: "2"

# Host aliases
# hostAliases:
# - ip: 127.0.0.1
#   hostnames:
#   - foo.local
#   - bar.local

# Termination grace period (seconds)
# terminationGracePeriodSeconds: 30

# Priority class
# priorityClassName: high-priority

# Runtime class
# runtimeClassName: nvidia

# Scheduler name
# schedulerName: custom-scheduler

# Share process namespace
# shareProcessNamespace: true

# Subdomain for headless services
# subdomain: ""

# Topology spread constraints
# topologySpreadConstraints:
# - maxSkew: 1
#   topologyKey: kubernetes.io/hostname
#   whenUnsatisfiable: DoNotSchedule
#   labelSelector:
#     matchLabels:
#       app: myapp

######################
# Kast system configuration
######################
spellbook:
  name: default
chapter:
  name: default
glyphs: {}
# Example glyphs integration:
# vault:
# - type: secret
#   name: app-secrets
#   format: plain
#   random: true
#   randomKey: password