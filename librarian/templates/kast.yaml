{{/*kast - Kubernetes arcane spelling technology
Copyright (C) 2023 namenmalkv@gmail.com
Licensed under the GNU GPL v3. See LICENSE file for details.
*/}}

{{- $spellbook :=  dict "appParams" $.Values.appParams  }}
{{- $_ := set $spellbook "name" (default $.Release.Name $.Values.name) }}

#se puede agregar un if aca para q si no este definido el libro haga un "ls" y ver q libros hay y haga de multibook on one sweep

{{- $path := printf "bookrack/%s/index.yaml" (default .Release.Name .Values.name) }}
{{- if .Files.Glob $path }}
  {{- $default := .Files.Get $path | fromYaml }}
  {{- $_ := mergeOverwrite $spellbook $default }}
{{- end }}

{{/*
  Two-pass appendix consolidation system:
  Pass 1: Collect all appendix (book, chapters, files) into $globalAppendix
  Pass 2: Generate Applications with multi-source trinket detection per-chapter
*/}}
{{- $globalAppendix := deepCopy (default dict $spellbook.appendix) }}

{{/* PASS 1: Collect all appendix from chapters and files */}}
{{- range $chapterName := $spellbook.chapters }}
  {{- $pathChapter := print "bookrack/" $spellbook.name "/" $chapterName "/index.yaml" }}
  {{- if $.Files.Glob $pathChapter }}
    {{- $chapterDef := $.Files.Get $pathChapter | fromYaml }}
    {{/* Merge chapter.appendix to global */}}
    {{- if $chapterDef.appendix }}
      {{- $_ := mergeOverwrite $globalAppendix (deepCopy $chapterDef.appendix) }}
    {{- end }}
  {{- end }}
  {{/* Collect appendix from all files in chapter */}}
  {{- $path := print "bookrack/" $spellbook.name "/" $chapterName "/*.y*ml"}}
  {{- range $spellPath, $_ := $.Files.Glob $path }}
    {{- if not (eq $spellPath (print "bookrack/" $spellbook.name "/" $chapterName "/index.yaml")) }}
      {{- $spellDefinition := ($.Files.Get $spellPath | fromYaml) }}
      {{/* Merge file.appendix to global */}}
      {{- if $spellDefinition.appendix }}
        {{- $_ := mergeOverwrite $globalAppendix (deepCopy $spellDefinition.appendix) }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}

{{/* PASS 2: Generate Applications with complete $globalAppendix */}}
{{ range $chapterName := $spellbook.chapters }}
  {{- $chapter := dict "name" $chapterName }}
  {{- $chapterLocalAppendix := dict }}

  {{/* Build trinketsByKey for this chapter: book.trinkets < chapter.trinkets */}}
  {{- $chapterTrinketsByKey := dict }}
  {{- if $spellbook.trinkets }}
    {{- range $name, $trinket := $spellbook.trinkets }}
      {{- if $trinket.key }}
        {{- $_ := set $chapterTrinketsByKey $trinket.key (deepCopy $trinket) }}
      {{- end }}
    {{- end }}
  {{- end }}

  {{- $pathChapter := print "bookrack/" $spellbook.name "/" $chapterName "/index.yaml" }}
  {{- if $.Files.Glob $pathChapter }}
    {{- $chapterDef := $.Files.Get $pathChapter | fromYaml }}
    {{- $chapter = $chapterDef }}
    {{- if not $chapter.name }}
      {{- $_ := set $chapter "name" $chapterName }}
    {{- end }}
    {{/* Store chapter localAppendix for override */}}
    {{- if $chapterDef.localAppendix }}
      {{- $chapterLocalAppendix = deepCopy $chapterDef.localAppendix }}
    {{- end }}
    {{/* Merge chapter.trinkets to chapterTrinketsByKey */}}
    {{- if $chapterDef.trinkets }}
      {{- range $name, $trinket := $chapterDef.trinkets }}
        {{- if $trinket.key }}
          {{- if hasKey $chapterTrinketsByKey $trinket.key }}
            {{- $_ := mergeOverwrite (index $chapterTrinketsByKey $trinket.key) (deepCopy $trinket) }}
          {{- else }}
            {{- $_ := set $chapterTrinketsByKey $trinket.key (deepCopy $trinket) }}
          {{- end }}
        {{- end }}
      {{- end }}
    {{- end }}
  {{- end }}
  {{- $path := print "bookrack/" $spellbook.name "/" $chapterName "/*.y*ml"}}
  {{- range $spellPath, $_ := $.Files.Glob $path }}
  {{- if not (eq $spellPath (print "bookrack/" $spellbook.name "/" $chapterName "/index.yaml")) }}
    {{- $appParams := deepCopy $spellbook.appParams }}
    {{- $spellDefinition := ($.Files.Get $spellPath | fromYaml) }}
    {{- $_ := mergeOverwrite $appParams (deepCopy (default dict $chapter.appParams) ) }}
    {{- $_ := mergeOverwrite $appParams (deepCopy (default dict $spellDefinition.appParams )) }}
    {{- $spell := (dict "name" $spellDefinition.name ) }}

    {{/* Create final appendix: global < chapterLocal < fileLocal */}}
    {{- $finalAppendix := deepCopy $globalAppendix }}
    {{- if $chapterLocalAppendix }}
      {{- $_ := mergeOverwrite $finalAppendix (deepCopy $chapterLocalAppendix) }}
    {{- end }}
    {{- if $spellDefinition.localAppendix }}
      {{- $_ := mergeOverwrite $finalAppendix (deepCopy $spellDefinition.localAppendix) }}
    {{- end }}

    {{/* Convert appendix.lexicon dict to list for backward compatibility */}}
    {{- $lexicon := list }}
    {{- if $finalAppendix.lexicon }}
      {{- range $name, $lexiconDef := $finalAppendix.lexicon }}
        {{- $item := deepCopy $lexiconDef }}
        {{/* Use .name if exists, otherwise use dict key */}}
        {{- if not (hasKey $item "name") }}
          {{- $_ := set $item "name" $name }}
        {{- end }}
        {{- $lexicon = append $lexicon $item }}
      {{- end }}
    {{- end }}

    {{/* Convert appendix.cards dict to list with name override support */}}
    {{- $cards := list }}
    {{- if $finalAppendix.cards }}
      {{- range $cardKey, $cardDef := $finalAppendix.cards }}
        {{- $item := deepCopy $cardDef }}
        {{/* Use .name if exists, otherwise use dict key */}}
        {{- if not (hasKey $item "name") }}
          {{- $_ := set $item "name" $cardKey }}
        {{- end }}
        {{- $cards = append $cards $item }}
      {{- end }}
    {{- end }}
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: {{ $spellDefinition.name }}
  namespace: {{ default "argocd" $spellbook.argocdNamespace }}
  {{- with ($spellDefinition.appParams).customFinalizers }}
  finalizers:
  {{- toYaml . | nindent 4 }}
  {{- end }}
  {{- with ($spellDefinition.appParams).annotations }}
  annotations:
  {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  project: {{ default (default (default $spellbook.projectName $chapter.projectName ) $spellbook.name ) ($spellDefinition.values).projectName }}
  {{- $cleanSpellbook := merge (dict "spellbook" (deepCopy $spellbook)) }}
  {{- $_ =  unset $cleanSpellbook.spellbook "appParams" }}
  {{- $_ =  unset $cleanSpellbook.spellbook "summon" }}
  {{- $_ =  unset $cleanSpellbook.spellbook "kaster" }}
  {{- $_ =  unset $cleanSpellbook.spellbook "appendix" }}
  {{- $_ =  unset $cleanSpellbook.spellbook "localAppendix" }}
  sources:
  {{- /* Source 1: Primary source (custom chart OR defaultTrinket) - ALWAYS */}}
  {{- if or $spellDefinition.chart $spellDefinition.path }}
    {{/* Custom chart/path */}}
    - repoURL: {{ $spellDefinition.repository }}
      {{- if $spellDefinition.chart }}
      chart: {{ $spellDefinition.chart }}
      {{- else }}
      path: {{ $spellDefinition.path }}
      {{- end }}
      targetRevision: {{ $spellDefinition.revision }}
    {{- if not ($spellDefinition.appParams).noHelm }}
      helm:
      {{- if ($spellDefinition.appParams).skipCrds }}
        skipCrds: true
      {{- end }}
      {{- if $spellDefinition.values }}
        values: |
          {{- toYaml $spellDefinition.values | nindent 10 }}
      {{- end }}
    {{- end }}
  {{- else }}
    {{/* defaultTrinket (summon) */}}
    {{- $defaultTrinket := default $spellbook.defaultTrinket $chapter.defaultTrinket }}
    - repoURL: {{ $defaultTrinket.repository }}
      {{- if $defaultTrinket.chart }}
      chart: {{ $defaultTrinket.chart }}
      {{- else }}
      path: {{ $defaultTrinket.path }}
      {{- end }}
      targetRevision: {{ $defaultTrinket.revision }}
      helm:
        {{- $values := mergeOverwrite (default dict (deepCopy (default dict $defaultTrinket.values)) ) $spellDefinition }}
        {{- $_ :=  unset $values "runes" }}
        {{- $_ :=  unset $values "appParams" }}
        {{- $_ :=  unset $values "appendix" }}
        {{- $_ :=  unset $values "localAppendix" }}
        {{/* Unset all trinket keys */}}
        {{- range $key, $_ := $chapterTrinketsByKey }}
          {{- $_ :=  unset $values $key }}
        {{- end }}
        values: |
          {{- toYaml $values | nindent 10 }}
          {{- toYaml $cleanSpellbook | nindent 10 }}
          {{- toYaml (dict "chapter" $chapter) | nindent 10 }}
          lexicon:
          {{- toYaml $lexicon | nindent 12 }}
          {{- if $cards }}
          cards:
          {{- toYaml $cards | nindent 12 }}
          {{- end }}
  {{- end }}
  {{- /* Sources 2..N: Additional trinket sources (dynamic detection) */}}
  {{- range $trinketKey, $trinket := $chapterTrinketsByKey }}
    {{- if hasKey $spellDefinition $trinketKey }}
      {{/* File has this trinket key (e.g., tarot, glyphs, X, etc.) */}}
    - repoURL: {{ $trinket.repository }}
      {{- if $trinket.chart }}
      chart: {{ $trinket.chart }}
      {{- else }}
      path: {{ $trinket.path }}
      {{- end }}
      targetRevision: {{ $trinket.revision }}
      helm:
        values: |
          {{- if eq $trinketKey "glyphs" }}
          {{/* kaster - only pass glyphs */}}
          glyphs:
          {{- toYaml (index $spellDefinition $trinketKey) | nindent 12 }}
          {{- else }}
          {{/* tarot and others - pass the key with its data */}}
          {{ $trinketKey }}:
          {{- toYaml (index $spellDefinition $trinketKey) | nindent 12 }}
          {{- end }}
          {{- toYaml $cleanSpellbook | nindent 10 }}
          {{- toYaml (dict "chapter" $chapter) | nindent 10 }}
          lexicon:
          {{- toYaml $lexicon | nindent 12 }}
          {{- if and (eq $trinketKey "tarot") $cards }}
          cards:
          {{- toYaml $cards | nindent 12 }}
          {{- end }}
    {{- end }}
  {{- end }}
  {{- /* runes */}}
  {{- $ignoreDiff := (default list $appParams.ignoreDifferences) }}
  {{- range $rune := $spellDefinition.runes }}
    {{- $ignoreDiff = concat $ignoreDiff (default list ($rune.appParams).ignoreDifferences) }}
    {{- if not ($rune.appParams).noOverite }}
      {{- $_ := mergeOverwrite $appParams (default dict $rune.appParams ) }}
    {{- end }}
    - repoURL: {{ $rune.repository }}
      {{- if $rune.chart }}
      chart: {{ $rune.chart }}
        {{- else }}
      path: {{ $rune.path }}
      {{- end }}
      targetRevision: {{ $rune.revision }}
    {{- if not ($rune.appParams).noHelm }}
      helm:
        {{- if ($rune.appParams).skipCrds }}
        skipCrds: true
        {{- end }}
        values: |
          {{- if $rune.values }}
          {{- toYaml $rune.values | nindent 10 }}
          {{- end }}
    {{- end }}
  {{- end }}
  destination:
    {{- $cluster := "" }}
    {{- $clusterSelector := default (default $spellbook.clusterSelector $chapter.clusterSelector ) $spellDefinition.clusterSelector }}
    {{- if $clusterSelector }}
      {{- $clusters := get (include "glyph.runicIndexer" (list $lexicon $clusterSelector "k8s-cluster" $chapter.name ) | fromJson) "results" }}
      {{- range $clusters }}
        {{- $cluster = .clusterURL}}
      {{- end }}
    {{- end }}
    server: {{ default "https://kubernetes.default.svc" $cluster }}
    namespace: {{ default $spellDefinition.name $spellDefinition.namespace }}
  syncPolicy:
    {{- if $appParams.managedNamespaceMetadata }}
      {{- with $appParams.managedNamespaceMetadata }}
    managedNamespaceMetadata:
    {{- toYaml . | nindent 6 }}
      {{- end }}
    {{- end }}
    {{- if not $appParams.disableAutoSync }}
    {{- with $appParams.syncPolicy.automated }}
    automated:
    {{- toYaml . | nindent 6 }}
    {{- end }}
    {{- end }}
    {{- with $appParams.syncPolicy.syncOptions }}
    syncOptions:
    {{- toYaml . | nindent 6 }}
    {{- end }}
    {{- with $appParams.syncPolicy.retry }}
    retry:
    {{- toYaml . | nindent 6 }}
    {{- end }}  
  {{- if $ignoreDiff }} ##TODO add ignore differences segun runas
  ignoreDifferences:
    {{- toYaml $ignoreDiff | nindent 4 }}
  {{- end }}
  {{- end }}
  {{- end }}
{{- end }}
