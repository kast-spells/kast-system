{{/*kast - Kubernetes arcane spelling technology
Copyright (C) 2023 namenmalkv@gmail.com
Licensed under the GNU GPL v3. See LICENSE file for details.

Covenant Resource Generator
Reads bookrack/covenant/ structure and generates Keycloak resources via glyphs

Capabilities:
- Generates KeycloakRealm per book
- Generates realm roles and client roles
- Creates users, groups, clients
- Configures Identity Providers (IDPs)
- Defines authentication flows
- Creates custom client scopes
- Integrates with Vault for OIDC secrets
*/}}

{{- $root := . }}
{{- $covenant := default dict .Values.covenant }}

{{/* Use .Values.name (from librarian) as bookPath, like librarian does */}}
{{/* If name contains a chapter suffix (e.g., covenant-tyl-fwck), extract base book name */}}
{{- $fullName := default .Release.Name .Values.name }}
{{- $bookPath := $fullName }}
{{- if $covenant.chapterFilter }}
  {{/* Remove chapter suffix from name to get book path */}}
  {{- $bookPath = trimSuffix (printf "-%s" $covenant.chapterFilter) $fullName }}
{{- end }}

{{/* Get chapterFilter if specified (for chapter-specific rendering) */}}
{{- $chapterFilter := $covenant.chapterFilter }}

{{/* Generate unique ServiceAccount name for post-provisioning jobs */}}
{{- $postProvisionSA := printf "%s-post-provision" $bookPath }}

{{/* Read covenant book index first to get realm name */}}
{{- $covenantIndexPath := printf "bookrack/%s/index.yaml" $bookPath }}
{{- if not (.Files.Glob $covenantIndexPath) }}
  {{- fail (printf "covenant/index.yaml not found in bookrack/%s" $bookPath) }}
{{- end }}
{{- $covenantIndex := .Files.Get $covenantIndexPath | fromYaml }}
{{- $finalRealm := $covenantIndex.realm }}

{{/* Set chapter name: use chapterFilter if provided, else use "identity" for main covenant */}}
{{- $chapterName := "" }}
{{- $chapterLabels := dict }}
{{- if $root.Values.chapter }}
  {{- $chapterName = $root.Values.chapter.name }}
  {{- $chapterLabels = dict "chapter" $chapterName }}
{{- else }}
  {{/* Main covenant (no chapterFilter): use "identity" as internal chapter for vault paths */}}
  {{- $chapterName = "identity" }}
{{- end }}

{{/* Ensure chapter context exists in $root.Values for vault/glyph templates */}}
{{- if not $root.Values.chapter }}
  {{- $_ := set $root.Values "chapter" (dict "name" $chapterName) }}
{{- end }}

{{- $keycloakInstances := get (include "runicIndexer.runicIndexer" (list $root.Values.lexicon $chapterLabels "keycloak" $chapterName) | fromJson) "results" }}
{{- $keycloakInstance := dict }}
{{- range $keycloakInstances }}
  {{- $keycloakInstance = . }}
{{- end }}
{{/* Extract Keycloak server CRD name from lexicon */}}
{{- $keycloakRef := required "keycloakInstance.keycloakCrdName is required in lexicon" $keycloakInstance.keycloakCrdName }}
{{/* Determine keycloakRef kind: use ClusterKeycloak if covenant is in different namespace than keycloak */}}
{{- $keycloakRefKind := "Keycloak" }}
{{- if ne $root.Release.Namespace $keycloakInstance.namespace }}
  {{- $keycloakRefKind = "ClusterKeycloak" }}
{{- end }}
{{/* Construct KeycloakRealm resource name from realm name in covenant index */}}
{{- $realmRef := printf "realm-%s" (required "covenant realm.name is required" $finalRealm.name) }}

{{/* Consolidated data structures */}}
{{- $consolidatedMembers := dict }}
{{- $consolidatedChapels := dict }}
{{- $consolidatedAreas := dict }}
{{- $consolidatedClientScopes := dict }}
{{- $consolidatedIDPs := dict }}
{{- $consolidatedAuthFlows := dict }}
{{- $consolidatedIntegrations := dict }}
{{- $consolidatedPostProvisioning := dict }}
{{- $consolidatedRoles := default dict $covenantIndex.roles }}

{{/* CONSOLIDATION: Read post-provisioning definitions from conventions/post-provisioning/*.yaml */}}
{{- range $postProvPath, $_ := .Files.Glob (printf "bookrack/%s/conventions/post-provisioning/*.yaml" $bookPath) }}
  {{- $postProvName := trimSuffix ".yaml" (base $postProvPath) }}
  {{- $postProvDef := ($.Files.Get $postProvPath | fromYaml) }}
  {{- if not (eq $postProvDef.enabled false) }}
    {{- $_ := set $consolidatedPostProvisioning $postProvName $postProvDef }}
  {{- end }}
{{- end }}

{{/* CONSOLIDATION: Read client scopes using scan helper */}}
{{- $consolidatedClientScopes = include "covenant.scanRealmClientScopes" . | fromJson }}

{{/* CONSOLIDATION: Read identity providers using scan helper */}}
{{- $consolidatedIDPs = include "covenant.scanRealmIDPs" . | fromJson }}

{{/* CONSOLIDATION: Read auth flows using scan helper */}}
{{- $consolidatedAuthFlows = include "covenant.scanRealmAuthFlows" . | fromJson }}

{{/* CONSOLIDATION: Read integrations using scan helper */}}
{{- $consolidatedIntegrations = include "covenant.scanRealmIntegrations" . | fromJson }}

{{/* PASS 1: Scan all chapters (or filter by chapterFilter if specified) */}}
{{/* Try new structure first (covenant/ subdir), fallback to old */}}
{{- $chapterIndexGlob := printf "bookrack/%s/covenant/*/index.yaml" $bookPath }}
{{- if not (.Files.Glob $chapterIndexGlob) }}
  {{- $chapterIndexGlob = printf "bookrack/%s/*/index.yaml" $bookPath }}
{{- end }}
{{- range $chapterPath, $_ := .Files.Glob $chapterIndexGlob }}
  {{- $chapterName := base (dir $chapterPath) }}
  
  {{/* Skip conventions, realm, and covenant directories */}}
  {{- if and (ne $chapterName "conventions") (ne $chapterName "realm") (ne $chapterName "covenant") }}

  {{/* Skip if chapterFilter is set and doesn't match */}}
  {{- if or (not $chapterFilter) (eq $chapterFilter $chapterName) }}

  {{- $chapterDef := ($.Files.Get $chapterPath | fromYaml) }}
  {{- $_ := set $consolidatedAreas $chapterName (deepCopy $chapterDef) }}

  {{/* Consolidate chapter-level roles */}}
  {{- if $chapterDef.roles }}
    {{- range $roleName, $roleDef := $chapterDef.roles }}
      {{- $chapterRoleKey := printf "%s-%s" $chapterName $roleName }}
      {{- if not (hasKey $consolidatedRoles $chapterRoleKey) }}
        {{- $_ := set $consolidatedRoles $chapterRoleKey $roleDef }}
      {{- end }}
    {{- end }}
  {{- end }}

  {{/* Consolidate chapter-level post-provisioning */}}
  {{- if $chapterDef.chapterPostProvisioning }}
    {{- range $postProv := $chapterDef.chapterPostProvisioning }}
      {{- if not (eq $postProv.enabled false) }}
        {{- $chapterPostProvKey := printf "%s-%s" $chapterName $postProv.name }}
        {{- $postProvWithContext := merge (deepCopy $postProv) (dict "chapter" $chapterName) }}
        {{- $_ := set $consolidatedPostProvisioning $chapterPostProvKey $postProvWithContext }}
      {{- end }}
    {{- end }}
  {{- end }}

  {{/* PASS 2: Scan all chapels (subdirectories) */}}
  {{/* Try new structure first (covenant/ subdir), fallback to old */}}
  {{- $chapelGlob := printf "bookrack/%s/covenant/%s/*/*.yaml" $bookPath $chapterName }}
  {{- if not ($.Files.Glob $chapelGlob) }}
    {{- $chapelGlob = printf "bookrack/%s/%s/*/*.yaml" $bookPath $chapterName }}
  {{- end }}
  {{- range $memberPath, $_ := $.Files.Glob $chapelGlob }}
    {{- $memberFileName := base $memberPath }}
    {{- $chapelName := base (dir $memberPath) }}
    {{- $memberName := trimSuffix ".yaml" (trimSuffix ".yml" $memberFileName) }}

    {{/* Register chapel if not seen */}}
    {{- $chapelKey := printf "%s/%s" $chapterName $chapelName }}
    {{- if not (hasKey $consolidatedChapels $chapelKey) }}
      {{- $_ := set $consolidatedChapels $chapelKey (dict "name" $chapelName "chapter" $chapterName) }}
    {{- end }}

    {{/* Read member file - file itself is the member definition */}}
    {{- $memberDef := ($.Files.Get $memberPath | fromYaml) }}

    {{/* Merge with chapter defaults */}}
    {{- $merged := deepCopy $memberDef }}
    {{- if $chapterDef.memberDefaults }}
      {{- $merged = mergeOverwrite (deepCopy $chapterDef.memberDefaults) $merged }}
    {{- end }}

    {{/* Add context */}}
    {{- $_ := set $merged "chapter" $chapterName }}
    {{- $_ := set $merged "chapel" $chapelName }}

    {{/* Auto-assign groups if not specified */}}
    {{- if not $merged.groups }}
      {{- $_ := set $merged "groups" (list $chapelKey $chapterName) }}
    {{- end }}

    {{- $fullMemberKey := printf "%s/%s/%s" $chapterName $chapelName $memberName }}
    {{- $_ := set $consolidatedMembers $fullMemberKey $merged }}
  {{- end }}
  {{- end }}  {{/* Close chapterFilter if */}}
  {{- end }}  {{/* Close skip directories if */}}
{{- end }}  {{/* Close chapter range */}}

{{/* Now generate glyphs for kaster to process */}}
{{- $keycloakGlyphs := dict }}
{{- $vaultGlyphs := dict }}
{{- $certManagerGlyphs := dict }}

{{/* STEP 0: Generate ServiceAccount and VaultPolicy for covenant (only for main covenant) */}}
{{- if not $chapterFilter }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ $fullName }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "common.labels" $root | nindent 4}}

{{/* Generate VaultPolicy and KubernetesAuthEngineRole for covenant */}}
{{/* Covenant needs write access to book/publics for OIDC client secrets */}}
{{- $_ := set $vaultGlyphs "covenant-policy" (dict
  "type" "vaultPolicy"
  "nameOverride" $fullName
  "serviceAccount" $fullName
  "bookPublicsWrite" true
) }}

{{- end }}

{{/* STEP 1: Generate KeycloakRealm for this covenant book (only if no chapterFilter - main covenant only) */}}
{{- if and $finalRealm (not $chapterFilter) }}

{{/* Generate stalwart-admin VaultSecret in keycloak namespace (shared across all chapters) */}}
{{/* This reads stalwart-admin from chapter path: /spellbook/chapter/publics/stalwart-admin */}}
{{/* Needed by post-provisioning jobs to authenticate to Stalwart REST API */}}
{{/* IMPORTANT: Only generate in main covenant (not chapterFilter), as it's a shared resource */}}
{{/* Path: "chapter" = /spellbook/chapter/publics/* accessible by covenant (read) and stalwart (write) */}}
{{- $stalwartAdminKey := "stalwart-admin" }}
{{- $_ := set $vaultGlyphs $stalwartAdminKey (dict
  "type" "vaultSecret"
  "name" "stalwart-admin"
  "namespace" .Release.Namespace
  "format" "plain"
  "randomKey" "password"
  "random" false
  "path" "book"
  "private" "admintools"
) }}
{{- $realmKey := print "realm-" (default "kast" $finalRealm.name) }}
{{- $_ := set $keycloakGlyphs $realmKey (dict
  "type" "realm"
  "realmName" (default "kast" $finalRealm.name)
  "displayName" (default "Kast Organization" $finalRealm.displayName)
  "keycloakRef" (default $keycloakRef $finalRealm.keycloakRef)
  "keycloakRefKind" $keycloakRefKind
  "enabled" (default true $finalRealm.enabled)
  "passwordPolicy" $finalRealm.passwordPolicy
  "themes" $finalRealm.themes
  "eventConfig" $finalRealm.eventConfig
  "tokenSettings" $finalRealm.tokenSettings
  "sslRequired" $finalRealm.sslRequired
) }}
{{- end }}

{{/* STEP 1.5: Generate Realm Roles from consolidated roles (only in main covenant, not chapter covenants) */}}
{{- if not $chapterFilter }}
{{- range $roleName, $roleDef := $consolidatedRoles }}
{{- $roleKey := printf "role-%s" $roleName }}
{{- $_ := set $keycloakGlyphs $roleKey (dict
  "type" "realmRole"
  "realmRef" $realmRef
  "roleName" $roleName
  "description" (default "" $roleDef.description)
  "composite" (default false $roleDef.composite)
  "compositeRoles" $roleDef.compositeRoles
  "attributes" $roleDef.attributes
) }}
{{- end }}
{{- end }}

{{/* STEP 2: Generate groups for chapters (areas) - only when chapterFilter is set */}}
{{- if $chapterFilter }}
{{- range $chapterName, $chapterDef := $consolidatedAreas }}
{{- $groupKey := printf "area-%s" $chapterName }}
{{- $_ := set $keycloakGlyphs $groupKey (dict
  "type" "group"
  "name" $chapterName
  "realmRef" $realmRef
  "realmRoles" (default list $chapterDef.realmRoles)
) }}
{{- end }}

{{/* STEP 3: Generate groups for chapels */}}
{{- range $chapelKey, $chapelDef := $consolidatedChapels }}
{{- $groupGlyphKey := printf "chapel-%s" ($chapelKey | replace "/" "-") }}
{{- $_ := set $keycloakGlyphs $groupGlyphKey (dict
  "type" "group"
  "name" ($chapelKey | replace "/" "-")
  "scopeName" $chapelKey
  "realmRef" $realmRef
) }}
{{- end }}

{{/* STEP 4: Generate users for members */}}
{{- range $memberKey, $member := $consolidatedMembers }}
{{- $userGlyphKey := $memberKey | replace "/" "-" }}
{{/* Auto-generate username and email from firstName.lastName@emailDomain with optional override */}}
{{- $baseUsername := "" }}
{{- if $member.overrideUsername }}
  {{- $baseUsername = $member.overrideUsername }}
{{- else }}
  {{- $baseUsername = printf "%s.%s" ($member.firstName | lower) ($member.lastName | lower) }}
{{- end }}
{{- $generatedUsername := printf "%s@%s" $baseUsername $finalRealm.emailDomain }}
{{/* Store generated values back into member for post-provisioning use */}}
{{- $_ := set $member "username" $generatedUsername }}
{{- $_ := set $member "email" $generatedUsername }}
{{- $_ := set $keycloakGlyphs $userGlyphKey (dict
  "type" "user"
  "realmRef" $realmRef
  "username" $generatedUsername
  "email" $generatedUsername
  "firstName" (default "" $member.firstName)
  "lastName" (default "" $member.lastName)
  "enabled" (ne (default "active" $member.status) "suspended")
  "emailVerified" (default true $member.emailVerified)
  "groups" $member.groups
) }}
{{- end }}
{{- end }}  {{/* Close chapterFilter if for users/groups */}}

{{/* STEP 5-8: Generate conventions (client scopes, IDPs, flows, integrations) - only for main covenant (no chapterFilter) */}}
{{- if not $chapterFilter }}

{{/* STEP 5: Generate custom Client Scopes from consolidated configuration */}}
{{- range $scopeName, $scopeDef := $consolidatedClientScopes }}
{{- $scopeKey := printf "scope-%s" $scopeName }}
{{- $_ := set $keycloakGlyphs $scopeKey (dict
  "type" "clientScope"
  "realmRef" $realmRef
  "scopeName" $scopeName
  "description" $scopeDef.description
  "protocol" (default "openid-connect" $scopeDef.protocol)
  "default" (default false $scopeDef.default)
  "protocolMappers" $scopeDef.protocolMappers
) }}
{{- end }}

{{/* STEP 6: Generate Identity Providers (IDPs) from consolidated configuration */}}
{{- range $idpName, $idpDef := $consolidatedIDPs }}
{{- if not (eq $idpDef.enabled false) }}
{{- $idpKey := printf "idp-%s" $idpName }}
{{- $_ := set $keycloakGlyphs $idpKey (dict
  "type" "idp"
  "realmRef" $realmRef
  "alias" $idpName
  "providerId" $idpDef.providerId
  "displayName" $idpDef.displayName
  "enabled" (default true $idpDef.enabled)
  "trustEmail" (default true $idpDef.trustEmail)
  "storeToken" (default true $idpDef.storeToken)
  "linkOnly" $idpDef.linkOnly
  "firstBrokerLoginFlowAlias" $idpDef.firstBrokerLoginFlowAlias
  "postBrokerLoginFlowAlias" $idpDef.postBrokerLoginFlowAlias
  "config" $idpDef.config
) }}

{{/* STEP 6.1: Generate Vault secret for IDP client_secret if configured */}}
{{- if $idpDef.secret }}
{{- $secretKey := printf "secret-%s-idp" $idpName }}
{{- $_ := set $vaultGlyphs $secretKey (dict
  "type" "vaultSecret"
  "name" $idpDef.secret
  "randomKey" "client_secret"
  "path" (default "book" $idpDef.vaultPath)
  "private" (default $fullName $idpDef.vaultPrivate)
  "passPolicyName" (default "simple-password-policy" $idpDef.passPolicyName)
  "selector" (default dict $idpDef.vaultSelector)
  "format" "plain"
) }}
{{- end }}
{{- end }}
{{- end }}

{{/* STEP 7: Generate Authentication Flows from consolidated configuration */}}
{{- range $flowName, $flowDef := $consolidatedAuthFlows }}
{{- $flowKey := printf "flow-%s" $flowName }}
{{- $_ := set $keycloakGlyphs $flowKey (dict
  "type" "flow"
  "realmRef" $realmRef
  "alias" $flowName
  "builtIn" (default false $flowDef.builtIn)
  "providerId" (default "basic-flow" $flowDef.providerId)
  "topLevel" (default true $flowDef.topLevel)
  "authenticationExecutions" $flowDef.authenticationExecutions
) }}
{{- end }}

{{/* STEP 8: Generate Keycloak clients from consolidated integrations */}}
{{- range $clientName, $clientDef := $consolidatedIntegrations }}
{{- if not (eq $clientDef.enabled false) }}
{{- $_ := set $keycloakGlyphs $clientName (dict
  "type" "client"
  "realmRef" $realmRef
  "clientId" (default $clientName $clientDef.clientId)
  "webUrl" $clientDef.webUrl
  "redirectUris" (default (list (printf "%s/*" $clientDef.webUrl)) $clientDef.redirectUris)
  "defaultClientScopes" (default (list "profile" "email" "roles" "groups") $clientDef.defaultClientScopes)
  "directAccess" (default true $clientDef.directAccess)
  "stdFlow" (default true $clientDef.standardFlowEnabled)
  "public" (default false $clientDef.public)
  "protocol" (default "openid-connect" $clientDef.protocol)
  "webOrigins" (default list $clientDef.webOrigins)
  "secret" $clientDef.secret
) }}

{{/* STEP 8.1: Generate Secrets (OIDC or SAML) */}}
{{- if $clientDef.secret }}
{{- $protocol := default "openid-connect" $clientDef.protocol }}

{{- if eq $protocol "saml" }}
{{/* 8.1.1 SAML: Generate Certificate via cert-manager */}}
{{/* Application will mount the cert-manager secret directly */}}
{{- $certKey := printf "cert-%s" $clientName }}
{{- $dnsName := regexReplaceAll "^https?://" $clientDef.webUrl "" | regexReplaceAll "/.*$" "" }}
{{- $entityId := default (printf "https://%s/saml/metadata" $dnsName) (default "" $clientDef.saml.entityId) }}
{{- $_ := set $certManagerGlyphs $certKey (dict
  "type" "certificate"
  "name" (printf "%s-saml" $clientName)
  "dnsNames" (list $dnsName)
  "commonName" $entityId
  "selector" (default (dict "environment" "production") $clientDef.certSelector)
) }}

{{- else }}
{{/* 8.1.1 OIDC: VaultSecret in keycloak namespace (generates random + adds static client_id) */}}
{{- $secretKeyKeycloak := printf "secret-%s-keycloak" $clientName }}
{{- $_ := set $vaultGlyphs $secretKeyKeycloak (dict
  "type" "vaultSecret"
  "name" $clientDef.secret
  "format" "plain"
  "staticData" (dict "client_id" (default $clientName $clientDef.clientId))
  "randomKey" "client_secret"
  "path" (default "book" $clientDef.vaultPath)
  "passPolicyName" (default "simple-password-policy" $clientDef.passPolicyName)
  "selector" (default dict $clientDef.vaultSelector)
) }}

{{/* 8.1.2: VaultSecret in target namespace (reads same vault path, adds static client_id) */}}
{{- if $clientDef.secretNamespace }}
{{- $secretKeyTarget := printf "secret-%s-target" $clientName }}
{{/* Build vault auth config */}}
{{- $vaultAuth := default dict $clientDef.vaultAuth }}
{{- $targetServiceAccount := default $clientDef.secretNamespace (default $clientDef.serviceAccount $vaultAuth.serviceAccount) }}
{{- $targetRole := default "" $vaultAuth.role }}
{{/* Build glyph dict with conditional customRole */}}
{{- $glyphDict := dict
  "type" "vaultSecret"
  "name" $clientDef.secret
  "namespace" $clientDef.secretNamespace
  "format" "plain"
  "staticData" (dict "client_id" (default $clientName $clientDef.clientId))
  "randomKey" "client_secret"
  "random" false
  "path" (default "book" $clientDef.vaultPath)
  "selector" (default dict $clientDef.vaultSelector)
  "serviceAccount" $targetServiceAccount
}}
{{- if $targetRole }}
{{- $_ := set $glyphDict "customRole" $targetRole }}
{{- end }}
{{- if $clientDef.secretLabels }}
{{- $_ := set $glyphDict "labels" $clientDef.secretLabels }}
{{- end }}
{{- $_ := set $vaultGlyphs $secretKeyTarget $glyphDict }}
{{- end }}

{{- end }}
{{- end }}
{{- end }}
{{- end }}

{{/* STEP 8.2: Generate Post-Provisioning for Integrations (ConfigMaps + Jobs via summon glyph) */}}
{{- range $clientName, $clientDef := $consolidatedIntegrations }}
  {{- if and (not (eq $clientDef.enabled false)) $clientDef.postProvisioning }}
    {{- $postProv := $clientDef.postProvisioning }}
    {{- if $postProv.enabled }}

{{/* Generate ConfigMap with the script */}}
{{- $scriptContent := "" }}
{{- if $postProv.scriptFile }}
  {{/* Read script from file in bookrack/{book}/scripts/ */}}
  {{- $scriptPath := printf "bookrack/%s/scripts/%s" $bookPath $postProv.scriptFile }}
  {{- if not ($.Files.Glob $scriptPath) }}
    {{- fail (printf "Post-provisioning scriptFile not found: %s" $scriptPath) }}
  {{- end }}
  {{- $scriptContent = $.Files.Get $scriptPath }}
{{- else if $postProv.script }}
  {{/* Use inline script */}}
  {{- $scriptContent = $postProv.script }}
{{- else }}
  {{- fail (printf "Integration %s postProvisioning requires either 'script' or 'scriptFile'" $clientName) }}
{{- end }}
{{- $configMapName := printf "%s-post-provision-script" $clientName }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ $configMapName }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.labels" $root | nindent 4}}
    covenant.kast.io/type: integration-provisioning
    covenant.kast.io/integration: {{ $clientName }}
data:
  {{ $configMapName }}: |
{{ $scriptContent | indent 4 }}

{{/* Build summon values for Job */}}
{{- $jobName := printf "%s-integration-provision" $clientName }}
{{- $scriptChecksum := $scriptContent | sha256sum }}

{{/* Get Vault instance from lexicon for template vars */}}
{{- $vaultInstances := get (include "runicIndexer.runicIndexer" (list $root.Values.lexicon $chapterLabels "vault" $chapterName) | fromJson) "results" }}
{{- $vaultInstance := dict }}
{{- range $vaultInstances }}
  {{- $vaultInstance = . }}
{{- end }}

{{/* Build env vars for template substitution in summon format (map of key: value) */}}
{{- $templateEnvs := dict }}
{{- $_ := set $templateEnvs "CLIENT_ID" (default $clientName $clientDef.clientId) }}
{{- $_ := set $templateEnvs "WEB_URL" $clientDef.webUrl }}
{{- $_ := set $templateEnvs "KEYCLOAK_URL" $keycloakInstance.url }}
{{- $_ := set $templateEnvs "KEYCLOAK_REALM" $finalRealm.name }}
{{- $_ := set $templateEnvs "INTEGRATION_NAME" $clientName }}
{{- if $vaultInstance.url }}
  {{- $_ := set $templateEnvs "VAULT_URL" $vaultInstance.url }}
{{- end }}
{{/* TODO: Handle postProv.env if user passes custom env vars */}}

{{/* Build volumes in summon format: separate configMaps, secrets, and volumes */}}
{{- $summonConfigMaps := dict }}
{{- $summonSecrets := dict }}
{{- $summonVolumes := dict }}

{{/* Add script ConfigMap - mount without 'key' to mount entire ConfigMap as directory */}}
{{- $scriptCfg := dict }}
{{- $_ := set $scriptCfg "mountPath" "/scripts" }}
{{- $_ := set $scriptCfg "contentType" "file" }}
{{- $_ := set $scriptCfg "location" "existing" }}
{{- $_ := set $summonConfigMaps $configMapName $scriptCfg }}

{{/* Add OIDC secret if exists - expose via envFrom as environment variables */}}
{{- if $clientDef.secret }}
  {{- $_ := set $summonSecrets $clientDef.secret (dict
    "contentType" "env"
    "location" "existing"
  ) }}
{{- end }}

{{/* Add user-defined volumes */}}
{{- if $postProv.volumes }}
  {{- range $volName, $volDef := $postProv.volumes }}
    {{- if eq $volDef.type "configMap" }}
      {{- $_ := set $summonConfigMaps $volName (merge $volDef (dict "contentType" "file" "location" "existing")) }}
    {{- else if eq $volDef.type "secret" }}
      {{- $_ := set $summonSecrets $volName (merge $volDef (dict "contentType" "file" "location" "existing")) }}
    {{- else }}
      {{- $_ := set $summonVolumes $volName $volDef }}
    {{- end }}
  {{- end }}
{{- end }}

{{/* Build summon-compatible values dict */}}
{{- $summonValues := dict }}
{{- $_ := set $summonValues "name" $jobName }}
{{- $_ := set $summonValues "namespace" $root.Release.Namespace }}
{{/* Build workload config from postProv or use defaults */}}
{{- $_ := set $summonValues "workload" (dict
  "enabled" true
  "type" "job"
  "backoffLimit" (default 3 $postProv.backoffLimit)
  "activeDeadlineSeconds" (default 600 $postProv.activeDeadlineSeconds)
  "restartPolicy" (default "Never" $postProv.restartPolicy)
) }}

{{/* Image: use postProv.image if provided, else default to alpine/curl */}}
{{- $defaultImage := "alpine/curl" }}
{{- $_ := set $summonValues "image" (default $defaultImage $postProv.image) }}

{{/* Command: execute script mounted at /scripts (subPath mounts file directly at mountPath) */}}
{{- $_ := set $summonValues "command" (list "/bin/sh" "/scripts") }}

{{/* Environment variables, volumes, and other configs */}}
{{- $_ := set $summonValues "envs" $templateEnvs }}
{{- $_ := set $summonValues "configMaps" $summonConfigMaps }}
{{- $_ := set $summonValues "secrets" $summonSecrets }}
{{- $_ := set $summonValues "volumes" $summonVolumes }}
{{- $_ := set $summonValues "service" (dict "enabled" false) }}
{{- $_ := set $summonValues "serviceAccount" (dict "enabled" true "name" $postProvisionSA) }}

{{/* Resources: use postProv.resources if provided, else use defaults */}}
{{- $defaultResources := dict
  "limits" (dict "cpu" "100m" "memory" "128Mi")
  "requests" (dict "cpu" "50m" "memory" "64Mi")
}}
{{- $_ := set $summonValues "resources" (default $defaultResources $postProv.resources) }}

{{/* Add checksum annotation for ConfigMap changes */}}
{{- $_ := set $summonValues "podAnnotations" (dict "checksum/script" $scriptChecksum) }}

{{/* Add covenant-specific annotations to Job metadata */}}
{{- $_ := set $summonValues "annotations" (dict
  "covenant.kast.io/client-id" (default $clientName $clientDef.clientId)
  "covenant.kast.io/web-url" $clientDef.webUrl
  "covenant.kast.io/script-checksum" $scriptChecksum
) }}

{{/* Add covenant-specific labels */}}
{{- $_ := set $summonValues "labels" (dict
  "covenant.kast.io/type" "integration-provisioning"
  "covenant.kast.io/integration" $clientName
) }}

{{/* Generate Job using summon glyph */}}
{{- $jobContext := dict "Values" $summonValues "Release" $root.Release "Chart" $root.Chart }}
{{- include "summon.workload.job" $jobContext }}

    {{- end }}
  {{- end }}
{{- end }}

{{- end }}  {{/* Close conventions chapterFilter if */}}

{{/* STEP 9: Generate RBAC for Post-Provisioning Jobs - only once per chapter */}}
{{- if $chapterFilter }}
{{- if $consolidatedPostProvisioning }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ $postProvisionSA }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.labels" $root | nindent 4}}
    covenant.kast.io/type: post-provisioning
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ $postProvisionSA }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.labels" $root | nindent 4}}
    covenant.kast.io/type: post-provisioning
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "update", "patch", "get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ $postProvisionSA }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    {{- include "common.labels" $root | nindent 4}}
    covenant.kast.io/type: post-provisioning
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $postProvisionSA }}
subjects:
  - kind: ServiceAccount
    name: {{ $postProvisionSA }}
    namespace: {{ $root.Release.Namespace }}
{{- end }}

{{/* STEP 10: Generate Chapter-level Post-Provisioning Jobs - run once per chapter */}}
{{- range $postProvKey, $postProvDef := $consolidatedPostProvisioning }}
  {{/* Only process chapter-level post-provisioning (has .chapter context) */}}
  {{- if $postProvDef.chapter }}
    {{- $jobName := printf "%s-%s-%s" $bookPath $postProvDef.chapter $postProvDef.name }}

    {{/* Support both inline script and scriptFile */}}
    {{- $scriptContent := "" }}
    {{- if $postProvDef.scriptFile }}
      {{/* Read script from file in bookrack/{book}/scripts/ */}}
      {{- $scriptPath := printf "bookrack/%s/scripts/%s" $bookPath $postProvDef.scriptFile }}
      {{- if not ($.Files.Glob $scriptPath) }}
        {{- fail (printf "Chapter post-provisioning scriptFile not found: %s" $scriptPath) }}
      {{- end }}
      {{- $scriptContent = $.Files.Get $scriptPath }}
    {{- else if $postProvDef.script }}
      {{/* Use inline script */}}
      {{- $scriptContent = $postProvDef.script }}
    {{- else }}
      {{- fail (printf "Chapter %s postProvisioning '%s' requires either 'script' or 'scriptFile'" $postProvDef.chapter $postProvDef.name) }}
    {{- end }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $jobName }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ $postProvDef.name }}
    app.kubernetes.io/instance: {{ $root.Release.Name }}
    app.kubernetes.io/managed-by: {{ $root.Release.Service }}
    covenant.kast.io/chapter: {{ $postProvDef.chapter }}
    covenant.kast.io/post-provisioning: chapter
  annotations:
    covenant.kast.io/post-prov-name: {{ $postProvDef.name }}
spec:
  {{- if $postProvDef.backoffLimit }}
  backoffLimit: {{ $postProvDef.backoffLimit }}
  {{- else }}
  backoffLimit: 3
  {{- end }}
  {{- if $postProvDef.activeDeadlineSeconds }}
  activeDeadlineSeconds: {{ $postProvDef.activeDeadlineSeconds }}
  {{- end }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ $postProvDef.name }}
        app.kubernetes.io/instance: {{ $root.Release.Name }}
        covenant.kast.io/chapter: {{ $postProvDef.chapter }}
    spec:
      serviceAccountName: {{ $postProvisionSA }}
      {{- if $postProvDef.restartPolicy }}
      restartPolicy: {{ $postProvDef.restartPolicy }}
      {{- else }}
      restartPolicy: Never
      {{- end }}
      containers:
        - name: {{ $postProvDef.name }}
          image: {{ default "bitnami/kubectl:latest" $postProvDef.image }}
          command: ["/bin/sh", "-c"]
          args:
            - |
{{ $scriptContent | nindent 14 }}
          env:
            - name: CHAPTER_NAME
              value: {{ $postProvDef.chapter | quote }}
            - name: BOOK_PATH
              value: {{ $bookPath | quote }}
            - name: NAMESPACE
              value: {{ $root.Release.Namespace | quote }}
            - name: KEYCLOAK_URL
              value: {{ $keycloakInstance.url | quote }}
            - name: KEYCLOAK_REALM
              value: {{ $finalRealm.name | quote }}
            {{- if $postProvDef.env }}
            {{- toYaml $postProvDef.env | nindent 12 }}
            {{- end }}
          {{- if $postProvDef.resources }}
          resources:
            {{- toYaml $postProvDef.resources | nindent 12 }}
          {{- end }}
  {{- end }}
{{- end }}

{{/* STEP 11: Generate Member-level Post-Provisioning Jobs */}}
{{- range $memberKey, $member := $consolidatedMembers }}
  {{- $memberName := $member.username | default $member.email }}
  {{- $memberRoles := default list $member.realmRoles }}
  {{- $memberGroups := default list $member.groups }}

  {{/* Loop through each post-provisioning definition */}}
  {{- range $postProvName, $postProvDef := $consolidatedPostProvisioning }}
    {{- $conditionsMet := false }}

    {{/* Check if user has any required roles */}}
    {{- if $postProvDef.conditions.roles }}
      {{- range $requiredRole := $postProvDef.conditions.roles }}
        {{- if has $requiredRole $memberRoles }}
          {{- $conditionsMet = true }}
        {{- end }}
      {{- end }}
    {{- end }}

    {{/* Check if user has any required groups */}}
    {{- if $postProvDef.conditions.groups }}
      {{- range $requiredGroup := $postProvDef.conditions.groups }}
        {{- if has $requiredGroup $memberGroups }}
          {{- $conditionsMet = true }}
        {{- end }}
      {{- end }}
    {{- end }}

    {{/* If conditions are met, generate the Job */}}
    {{- if $conditionsMet }}
      {{- $jobName := printf "%s-%s-%s" $postProvName ($memberKey | replace "/" "-") "provision" }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $jobName }}
  namespace: {{ $root.Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ $postProvName }}
    app.kubernetes.io/instance: {{ $root.Release.Name }}
    app.kubernetes.io/managed-by: {{ $root.Release.Service }}
    covenant.kast.io/member: {{ $memberKey | replace "/" "-" }}
    covenant.kast.io/post-provisioning: {{ $postProvName }}
  annotations:
    covenant.kast.io/member-email: {{ $member.email }}
    covenant.kast.io/member-username: {{ $memberName }}
spec:
  {{- if $postProvDef.job.backoffLimit }}
  backoffLimit: {{ $postProvDef.job.backoffLimit }}
  {{- end }}
  {{- if $postProvDef.job.activeDeadlineSeconds }}
  activeDeadlineSeconds: {{ $postProvDef.job.activeDeadlineSeconds }}
  {{- end }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ $postProvName }}
        app.kubernetes.io/instance: {{ $root.Release.Name }}
        covenant.kast.io/member: {{ $memberKey | replace "/" "-" }}
    spec:
      serviceAccountName: {{ $postProvisionSA }}
      {{- if $postProvDef.job.restartPolicy }}
      restartPolicy: {{ $postProvDef.job.restartPolicy }}
      {{- else }}
      restartPolicy: Never
      {{- end }}
      containers:
        - name: {{ $postProvDef.container.name }}
          image: {{ $postProvDef.container.image.name }}:{{ $postProvDef.container.image.tag }}
          {{- if $postProvDef.container.command }}
          command:
            {{- range $postProvDef.container.command }}
            - {{ . }}
            {{- end }}
          {{- end }}
          {{- if $postProvDef.container.args }}
          args:
            {{- range $arg := $postProvDef.container.args }}
            {{- $templatedArg := $arg }}
            {{- $templatedArg = $templatedArg | replace "{{ .username }}" $memberName }}
            {{- $templatedArg = $templatedArg | replace "{{ .email }}" $member.email }}
            {{- $templatedArg = $templatedArg | replace "{{ .firstName }}" (default "" $member.firstName) }}
            {{- $templatedArg = $templatedArg | replace "{{ .lastName }}" (default "" $member.lastName) }}
            {{- $templatedArg = $templatedArg | replace "{{ .groups | join \",\" }}" (join "," $memberGroups) }}
            {{- $templatedArg = $templatedArg | replace "{{ .groups | toJson }}" (toJson $memberGroups) }}
            - {{ $templatedArg | quote }}
            {{- end }}
          {{- end }}
          env:
            {{- if $postProvDef.container.env }}
            {{- toYaml $postProvDef.container.env | nindent 12 }}
            {{- end }}
            # Dynamic values from lexicon (via runicIndexer)
            - name: KEYCLOAK_URL
              value: {{ $keycloakInstance.url | quote }}
            - name: KEYCLOAK_REALM
              value: {{ $finalRealm.name | quote }}
          {{- if $postProvDef.container.resources }}
          resources:
            {{- toYaml $postProvDef.container.resources | nindent 12 }}
          {{- end }}
    {{- end }}
  {{- end }}
{{- end }}
{{- end }}  {{/* Close chapterFilter if for post-provisioning */}}

{{/* Generate Keycloak resources using glyphs */}}
{{- range $glyphName, $glyph := $keycloakGlyphs }}
  {{- $glyphWithName := merge $glyph (dict "name" $glyphName) }}
  {{- if eq $glyph.type "realm" }}
    {{- include "keycloak.realm" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "realmRole" }}
    {{- include "keycloak.realmRole" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "clientScope" }}
    {{- include "keycloak.clientScope" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "idp" }}
    {{- include "keycloak.idp" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "flow" }}
    {{- include "keycloak.flow" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "group" }}
    {{- include "keycloak.group" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "user" }}
    {{- include "keycloak.user" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "client" }}
    {{- include "keycloak.client" (list $root $glyphWithName) }}
  {{- end }}
{{- end }}

{{/* Generate cert-manager resources using glyphs */}}
{{- range $glyphName, $glyph := $certManagerGlyphs }}
  {{- if eq $glyph.type "certificate" }}
    {{- include "certManager.certificate" (list $root $glyph) }}
  {{- end }}
{{- end }}

{{/* Generate Vault resources using glyphs */}}
{{- range $glyphName, $glyph := $vaultGlyphs }}
  {{- $glyphWithName := merge $glyph (dict "name" $glyphName) }}
  {{- if eq $glyph.type "randomSecret" }}
    {{- include "vault.randomSecret" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "vaultSecret" }}
    {{- include "vault.secret" (list $root $glyphWithName) }}
  {{- else if eq $glyph.type "vaultPolicy" }}
    {{- include "vault.prolicy" (list $root $glyphWithName) }}
  {{- end }}
{{- end }}

